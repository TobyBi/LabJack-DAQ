<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tdaq API documentation</title>
<meta name="description" content="LabJack-DAQ …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tdaq</code></h1>
</header>
<section id="section-intro">
<h1 id="labjack-daq">LabJack-DAQ</h1>
<p>Object-oriented wrapper of LabJack LJM
to control LabJack <a href="https://labjack.com/products/t7">T-Series DAQs</a>. Classes are provided for timed interval control, asynchronous communication, and output steaming of DACs.</p>
<h2 id="requirements">Requirements</h2>
<ul>
<li>Python &gt;= 3.8.5</li>
<li>numpy &gt;= 1.19.5</li>
<li><a href="https://labjack.com/support/software/installers/ljm">LabJack LJM library</a></li>
</ul>
<p>Only written and tested with LabJack T7 DAQ.</p>
<h2 id="installation">Installation</h2>
<p>To install simply clone the git directory using the following commands:</p>
<pre><code class="language-bash">git clone https://github.com/TobyBi/LabJack-DAQ
</code></pre>
<p>Move the file <code><a title="tdaq" href="#tdaq">tdaq</a></code> to your own directory and import it to use.</p>
<h2 id="usage">Usage</h2>
<p>Create a <code><a title="tdaq.LabJackDaq" href="#tdaq.LabJackDaq">LabJackDaq</a></code> object and add desired components to use it. The available components are</p>
<ul>
<li><code><a title="tdaq.Updater" href="#tdaq.Updater">Updater</a></code> for reading and writing to LabJack registers,</li>
<li><code><a title="tdaq.AsynchUpdater" href="#tdaq.AsynchUpdater">AsynchUpdater</a></code> for using asynchronous read and write to LabJack registers,</li>
<li><code><a title="tdaq.Intervaler" href="#tdaq.Intervaler">Intervaler</a></code> which allows ensures commands run within a certain interval, and</li>
<li><code><a title="tdaq.Streamer" href="#tdaq.Streamer">Streamer</a></code> which streams data from the LabJack at a set rate.</li>
</ul>
<p>More details are included in the documentation <a href="https://tobybi.github.io/LabJack-DAQ/tdaq.html">here</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ./README.md
&#34;&#34;&#34;

import numpy as np
import time
from random import randint
from labjack import ljm

def convert_input(val):
    &#34;&#34;&#34;Convert single length input to iterable (``list`` or ``tuple``).

    Parameters
    ----------
    val : any type
        Can be ``list``, ``tuple``, ``numpy.ndarray`` or any type.

    Returns
    -------
    iter_val : ``list`` or ``tuple``
        Iterable output.
    &#34;&#34;&#34;
    if not isinstance(val, tuple) and not isinstance(val, list):
        if isinstance(val, np.ndarray):
            # np.ndarray can only be converted to list this way
            iter_val = list(val)
        else:
            # any other variable needs this way
            iter_val = [val]
    else:
        iter_val = val
    return iter_val


class LabJackDaq:
    &#34;&#34;&#34;Wrapper for LabJack LJM library, to execute read and write timings and data loading.

    Written for T-Series products such as the T4 and T7.

    The handle and ``Updater``, ``AsynchUpdater``, ``Intervaler``, and
    ``Streamer``.

    Parameters
    ----------
    device_type : str
        From LJM docs: A string containing the type of the device to be
        connected, optionally prepended by &#34;LJM_dt&#34;. Possible values include
        &#34;ANY&#34;, &#34;T4&#34;, &#34;T7&#34;, and &#34;DIGIT&#34;.
    connection_type : str
        From LJM docs: A string containing the type of the connection desired,
        optionally prepended by &#34;LJM_ct&#34;. Possible values include &#34;ANY&#34;, &#34;USB&#34;,
        &#34;TCP&#34;, &#34;ETHERNET&#34;, and &#34;WIFI&#34;.
    identifier : str
        From LJM docs: A string identifying the device to be connected or
        &#34;LJM_idANY&#34;/&#34;ANY&#34;. This can be a serial number, IP address, or device
        name. Device names may not contain periods.

    Notes
    -----
    Please refer to the following links for more details:
    https://labjack.com/support/datasheets/t-series
    https://labjack.com/support/datasheets/t-series/communication/modbus-map
    https://labjack.com/support/software/api/ljm
    &#34;&#34;&#34;
    def __init__(
        self, device_type=&#34;ANY&#34;, connection_type=&#34;ANY&#34;, identifier=&#34;ANY&#34;):
        &#34;&#34;&#34;Init a LabJackControl object.&#34;&#34;&#34;
        self.handle = ljm.openS(device_type, connection_type, identifier)
        print(
            &#34;Device type: {0}, connection type: {1}, ID: {2}, IP: {3}, port: {4}, Max {5} MB per packet&#34;.format(
                *ljm.getHandleInfo(self.handle)
                )
            )
        # TODO: error handling

    @classmethod
    def experiment(cls, exp_name: str):
        &#34;&#34;&#34;Init a LabJack object and other components based on experiment name.&#34;&#34;&#34;
        if exp_name == &#34;reflow&#34;:
            lj = cls(device_type=&#34;T4&#34;)
            lj.add_asynch(exp_name)
        elif exp_name == &#34;machining&#34;:
            lj = cls(device_type=&#34;T7&#34;)
            lj.add_asynch(exp_name)
            lj.add_update(
                write_names=[&#34;DAC0_BINARY&#34;, &#34;DAC1_BINARY&#34;],
                read_names=[&#34;DAC0&#34;, &#34;DAC1&#34;]
                )
            lj.add_stream_out(out_names=[&#34;DAC0&#34;, &#34;DAC1&#34;])
        else:
            raise ValueError(&#34;Please choose a valid experiment name.&#34;)
        return lj

    def close(self):
        &#34;&#34;&#34;Close connection between host and LabJack.&#34;&#34;&#34;
        try:
            ljm.close(self.handle)
        except ljm.LJMError as e:
            if e.errorString != &#34;LJME_DEVICE_NOT_OPEN&#34;:
                raise ljm.LJMError(&#34;Cannot close LabJack - unsure why.&#34;)

    def add_update(self, write_names, read_names):
        &#34;&#34;&#34;Add an ``Updater``, refer to the class for more info.&#34;&#34;&#34;
        self.update = Updater(self.handle, write_names, read_names)

    def add_stream_out(self, out_names, in_names=None):
        &#34;&#34;&#34;Add a ``Streamer``, refer to the class for more info.&#34;&#34;&#34;
        self.stream_out = Streamer.init_reset(
            self.handle, out_names, in_names=in_names
            )

    def add_asynch(self, exp_name: str):
        &#34;&#34;&#34;Add a ``AsynchUpdater``, refer to the class for more info.&#34;&#34;&#34;
        self.asynch = AsynchUpdater.experiment(self.handle, exp_name=exp_name)

    def add_interval(self, interval_time: float, num_iter: int):
        &#34;&#34;&#34;Add a ``Intervaler``, refer to the class for more info.&#34;&#34;&#34;
        self.interval = Intervaler(interval_time, num_iter)


class Updater:
    &#34;&#34;&#34;LabJack reader and writer to registers.

    Read and write registers can be the same or different.

    Parameters
    ----------
    handle : int
        Labjack handle.
    write_names : list, tuple, or str
        Write register names.
    read_names : list, tuple or str
        Read register names.

    &#34;&#34;&#34;

    def __init__(self, handle: int, write_names, read_names):
        &#34;&#34;&#34;Inits an Updater object.&#34;&#34;&#34;
        self._handle = handle

        self.write_names = convert_input(write_names)
        self.read_names = convert_input(read_names)

    @classmethod
    def same_registers(cls, handle: int, reg_names):
        &#34;&#34;&#34;Inits an Updater object with the same read and write registers.&#34;&#34;&#34;
        return cls(handle, reg_names, reg_names)

    @property
    def same_registers(self) -&gt; bool:
        &#34;&#34;&#34;Checks if the read and write registers are the same.&#34;&#34;&#34;
        same = set(self.write_names) == set(self.read_names)
        return same

    def read(self) -&gt; dict:
        &#34;&#34;&#34;Read from Labjack registers.

        Returns
        -------
        read_dict : dict
            Dict in the format ``{register_name : data}``.
        &#34;&#34;&#34;
        read_data = ljm.eReadNames(
            self._handle, len(self.read_names), self.read_names
            )
        read_dict = {
            name: data for name, data in zip(self.read_names, read_data)
            }
        return read_dict

    def write(self, datas):
        &#34;&#34;&#34;Write to Labjack registers with input data.

        Parameters
        ----------
        datas : tuple, list or anything
        &#34;&#34;&#34;
        # Single-valued data is converted into a list
        iter_datas = convert_input(datas)

        if len(iter_datas) != len(self.write_names):
            raise ValueError

        ljm.eWriteNames(
            self._handle, len(self.write_names), self.write_names, iter_datas
            )

    def update(self, datas) -&gt; dict:
        &#34;&#34;&#34;Write to and read from Labjack.

        If read and write registers are different then reads from
        object-defined read registers.

        Parameters
        ----------
        datas : tuple, list or anything
            Input data.

        Returns
        -------
        read_dict : dict
            See ``Updater.read``.

        Raises
        ------
        ValueError
            Length of data to write doesn&#39;t match number of write registers.
        &#34;&#34;&#34;
        # ljm.eReadNames only works with list/tuple names so must be converted
        iter_datas = convert_input(datas)

        if len(iter_datas) != len(self.write_names):
            raise ValueError(
                &#34;Length of data to write doesn&#39;t match number of write registers&#34;
                )

        ljm.eWriteNames(
            self._handle, len(self.write_names), self.write_names, iter_datas
            )

        if self.same_registers:
            # Read the same registers after writing to them.
            read_data = ljm.eReadNames(
                self._handle, len(self.write_names), self.write_names
                )
            read_dict = {
                name: data for name, data in zip(self.write_names, read_data)
                }
        else:
            read_dict = self.read()

        return read_dict


class AsynchUpdater:
    &#34;&#34;&#34;LabJack universial asynchronous receiver-transmitter (UART) serial communication.

    If asynchronous communication is used with the same AsynchUpdater object,
    then also ensures a 50ms delay between each receive or transmit action.

    Parameters
    ----------
    handle : int
        LabJack handle.

    Raises
    ------
    ValueError
        Must be either &#34;reflow&#34; or &#34;machining&#34;, to set which
        registers are used for asynchronous communication.

    Notes
    -----
    LabJack T4/T7 UART serial communication has the same timing and protocol as
    RS-232, however, the electrical specifications are different.
    T4/T7:
        low = 0V (0-0.5)
        high = 3.3V (2.64-5.8)
    RS-232:
        low = 3-25V
        high = -3-25V
    Connection using RS-232 requires a converter chip such as MAX233.

    For more details on UART serial communication on a LabJack, please visit:
    https://labjack.com/support/datasheets/t-series/digital-io/asynchronous-serial
    &#34;&#34;&#34;
    min_time_interval = 50e3
    &#34;&#34;&#34;Time interval between sending commands to allow command to be received.
    Unit in μs should be 50ms&#34;&#34;&#34;

    def __init__(self, handle: int):
        &#34;&#34;&#34;Inits an AsynchUpdater object.&#34;&#34;&#34;
        self._handle = handle
        self._last_host_tick = ljm.getHostTick()

        # if experiment in ASYNCH_CONFIG_REGISTERS.keys():
        #     self.experiment = experiment
        # else:
        #     raise ValueError(&#34;Experiment &#39;{0}&#39; doesn&#39;t exist! Please choose &#39;{1}&#39; or &#39;{2}&#39;&#34;.format(experiment, *ASYNCH_CONFIG_REGISTERS.keys()))

    @property
    def _asynch_enabled(self) -&gt; bool:
        &#34;&#34;&#34;Return if asynch communications is enabled.&#34;&#34;&#34;
        enabled = bool(ljm.eReadName(self._handle, &#34;ASYNCH_ENABLE&#34;))
        return enabled

    @classmethod
    def experiment(cls, handle: int, exp_name: str):
        &#34;&#34;&#34;Inits an AsynchUpdater object and Asynch communication based on experiment.

        Raises
        ------
        ValueError
            Must be either &#34;reflow&#34; or &#34;machining&#34;, to set which registers are
            used for Asynch communication.
        &#34;&#34;&#34;
        au = cls(handle)
        if exp_name == &#34;reflow&#34;:
            reflow_asynch_conf = {
                &#34;tx&#34;:               5,
                &#34;rx&#34;:               4,
                &#34;baud&#34;:             9600,
                &#34;rx_buffer&#34;:        6,
                &#34;num_data_bits&#34;:    0,
                &#34;num_stop_bits&#34;:    1,
                &#34;parity&#34;:           0
            }
            au.init_asynch(**reflow_asynch_conf)
        elif exp_name == &#34;machining&#34;:
            machine_asynch_conf = {
                &#34;tx&#34;:               1,
                &#34;rx&#34;:               0,
                &#34;baud&#34;:             9600,
                &#34;rx_buffer&#34;:        6,
                &#34;num_data_bits&#34;:    0,
                &#34;num_stop_bits&#34;:    1,
                &#34;parity&#34;:           0
            }
            au.init_asynch(**machine_asynch_conf)
        else:
            raise ValueError(&#34;Experiment &#39;{0}&#39; doesn&#39;t exist!&#34;)
        return au

    @classmethod
    def with_configuration(cls, handle: int, **kwargs):
        &#34;&#34;&#34;Inits an AsynchUpdater object and Asynch communication configuration.

        Raises
        ------
        TypeError
            Configuration registers are not valid LabJack registers.
        &#34;&#34;&#34;
        au = cls(handle)
        try:
            au.init_asynch(**kwargs)
        except TypeError:
            raise TypeError(
                &#34;Please enter valid Asynch configuration register names.&#34;
                )
        return au

    def _check_interval(self):
        &#34;&#34;&#34;Check interval time between two asynch actions is greater than 50ms.&#34;&#34;&#34;
        # TODO: needs sleep here?
        if (ljm.getHostTick() - self._last_host_tick) &lt; self.min_time_interval:
            time.sleep(self.min_time_interval/1e6)

    def init_asynch(
        self, tx: int=0, rx: int=0, baud: int=0, rx_buffer: int=0,
        num_data_bits: int=0, num_stop_bits: int=0, parity: int=0
        ):
        &#34;&#34;&#34;Configure LabJack for Asynch communication.

        After configuring each LabJack register, ASYNCH_ENABLE is passed 1 to
        turn on Asynch communication.

        Parameters
        ----------
        tx : int, optional
            ASYNCH_TX_DIONUM, digital I/O line that transmits data, by default 0.
        rx : int, optional
            ASYNCH_RX_DIONUM, digital I/O line that receives data, by default 0.
        baud : int, optional
            ASYNCH_BAUD, symbol rate for communication, by default 0. Typical
            values are 9600 and 38600 is the maximum.
        rx_buffer : int, optional
            ASYNCH_RX_BUFFER_SIZE_BYTES, number of bytes of receiving buffer,
            by default 0. Max is 2048 and 0 = 200.
        num_data_bits : [0, 1, 2, 3, 4, 5, 6, 7, 8], optional
            ASYNCH_NUM_DATA_BITS, number of bits per frame, by default 0. 0 = 8.
        num_stop_bits : [0, 1, 2], optional
            ASYNCH_NUM_STOP_BITS, number of stop bits, by default 0.
            0 = zero stop bits,
            1 = one stop bit,
            2 = two stop bits.
        parity : [0, 1, 2], optional
            ASYNCH_PARITY, by default 0.
            0 = none,
            1 = odd,
            2 = even.
        &#34;&#34;&#34;

        if self._asynch_enabled:
            ljm.eWriteName(self._handle, &#34;ASYNCH_ENABLE&#34;, 0)

        ljm.eWriteName(self._handle, &#34;ASYNCH_TX_DIONUM&#34;, tx)
        ljm.eWriteName(self._handle, &#34;ASYNCH_RX_DIONUM&#34;, rx)
        ljm.eWriteName(self._handle, &#34;ASYNCH_BAUD&#34;, baud)
        ljm.eWriteName(self._handle, &#34;ASYNCH_RX_BUFFER_SIZE_BYTES&#34;, rx_buffer)
        ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_DATA_BITS&#34;, num_data_bits)
        ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_STOP_BITS&#34;, num_stop_bits)
        ljm.eWriteName(self._handle, &#34;ASYNCH_PARITY&#34;, parity)
        # Turn on Asynch communication
        ljm.eWriteName(self._handle, &#34;ASYNCH_ENABLE&#34;, 1)

        # reg_names = [key for key in ASYNCH_CONFIG_REGISTERS[self.experiment].keys()]
        # reg_datas = [val for val in ASYNCH_CONFIG_REGISTERS[self.experiment].values()]
        # ljm.eWriteNames(self._handle, len(reg_names), reg_names, reg_datas)

        print(&#34;Initialisation of Asynch comms. successful!&#34;)

    def transmit(self, data: list):
        &#34;&#34;&#34;Asynchronously transmit serial data to device via LabJack TX line.

        Parameters
        ----------
        data : list
            List containing serial frame message.

        TODO: check if tuple, list works - then can use same function from
        Updater
        &#34;&#34;&#34;
        self._check_interval()
        ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_BYTES_TX&#34;, len(data))
        ljm.eWriteNameArray(self._handle, &#34;ASYNCH_DATA_TX&#34;, len(data), data)
        # Initiate a transmission via the buffer
        ljm.eWriteName(self._handle, &#34;ASYNCH_TX_GO&#34;, 1)

        self._last_host_tick = ljm.getHostTick()

    def receive(self) -&gt; list:
        &#34;&#34;&#34;Asynchronously receive serial data from device via LabJack RX line.

        Returns
        -------
        asynch_rx_vals : list
            Asynch response from device via LabJack RX line.
        &#34;&#34;&#34;
        self._check_interval()
        num_rx_vals = int(ljm.eReadName(self._handle, &#34;ASYNCH_NUM_BYTES_RX&#34;))
        asynch_rx_vals = ljm.eReadNameArray(
            self._handle, &#34;ASYNCH_DATA_RX&#34;, num_rx_vals
            )
        self._last_host_tick = ljm.getHostTick()
        return asynch_rx_vals


class Intervaler:
    &#34;&#34;&#34;Sets up a timed interval loop using a LabJack.

    A timed interval loop ensures that operations within the loop (before
    ljm.waitForNextInterval) occurs within the specified interval time. If it
    cannot, then it tries to perform the operations in the next interval and
    skipped intervals are reported.

    Parameters
    ----------
    interval_time : float
        Time of each iteration of the interval in μs.
    num_iter : int
        Number of iterations.

    Notes
    -----
    For more details about timing, refer to:
    https://labjack.com/support/software/api/ljm/function-reference/timing-functions/ljmstartinterval

    TODO: LUA scripting instead
    &#34;&#34;&#34;

    def __init__(self, interval_time: float, num_iter: int):
        &#34;&#34;&#34;Inits an Intervaler object.&#34;&#34;&#34;
        # each interval has its own handle as well
        self._interval_handle = randint(1, 999)
        self.interval_time = interval_time
        self.num_iter = num_iter

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        ljm.cleanInterval(self._interval_handle)
        if exc_type is KeyboardInterrupt:
            print(&#34;Interval stopped by user.&#34;)
            return False

        return exc_type is None

    @staticmethod
    def _add_responses(resp_list: list, resp) -&gt; list:
        &#34;&#34;&#34;Either add or concatenate responses.&#34;&#34;&#34;
        if isinstance(resp, list):
            resp_list += resp
        elif resp != &#34;&#34;:
            resp_list.append(resp)
        return resp_list

    def start_interval(
        self, operations_inside, operations_outside=None,
        **operation_kwargs) -&gt; dict:
        &#34;&#34;&#34;Start a timed interval with operations inside and outside an interval.

        Functions operations_inside and operations_outside must accept as
        arguments:
            - curr_iter as an argument,
            - all of the optional operation_kwargs
        and must return
            - curr_iter as an argument (curr_iter must be incremented within
            operations_inside otherwise an infinite loop will occur
            - any read data (can be an empty string).

        Parameters
        ----------
        operations_inside : function
            Functions to execute inside a timed interval.
        operations_outside : function, optional
            Functions to execute outside a timed interval, right after the
            timed interval has finished, by default None.
        operation_kwargs : optional
            Keyword arguments for operations_inside or operations_outside,
            if requried.

        Returns
        -------
        response : dict
            Contains metrics on interval_time, total_time (total run time) and
            any responses from the LabJack.
        &#34;&#34;&#34;
        with self:
            curr_iter = 0
            all_interval_t = []
            interval_responses = []
            ljm.startInterval(self._interval_handle, self.interval_time)
            t_before_loop = ljm.getHostTick()

            while curr_iter &lt; self.num_iter:
                t_start_interval = ljm.getHostTick()
                # run the operation inside a loop, allowing operation to
                # change iteration number
                curr_iter, resp = operations_inside(
                    curr_iter, **operation_kwargs
                    )
                skipped = ljm.waitForNextInterval(self._interval_handle)
                t_end_interval = ljm.getHostTick()

                interval_responses = self._add_responses(
                    interval_responses, resp
                    )
                all_interval_t.append(t_end_interval - t_start_interval)

                if operations_outside != None:
                    # operations outside of the timed loop, called
                    # *immediately* after the timed interval has ended
                    dummy_iter, resp = operations_outside(
                        curr_iter, **operation_kwargs
                        )

                    interval_responses = self._add_responses(
                        interval_responses, resp
                        )

                if skipped &gt; 0:
                    print(&#34;Iteration {0} skipped intervals: {1}&#34;.format(
                        curr_iter, skipped
                        ))

            total_time = ljm.getHostTick() - t_before_loop
            # Context manager handles cleaning the interval already
            # ljm.cleanInterval(self._interval_handle)

            response = {
                &#34;interval_time&#34;: np.mean(all_interval_t),
                &#34;total_time&#34;: total_time,
                &#34;response&#34;: interval_responses
            }

            return response

class Streamer:
    &#34;&#34;&#34;Streaming data from buffer to output mode via the LabJack.

    Parameters
    ----------
    handle : int
        LabJack handle.
    out_names : any
        List of register names for stream-out.
    in_names : any, optional
        NotImplemented, by default None

    Notes
    -----
    Please refer to the following links for further details on the registers:
    https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out
    https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out/stream-out-description
    &#34;&#34;&#34;

    def __init__(self, handle: int, out_names, in_names=None):
        &#34;&#34;&#34;Inits a Streamer object.&#34;&#34;&#34;
        self._handle = handle

        self.out_names = convert_input(out_names)
        self.in_names = in_names    # Not yet implemented

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        for stream_num in self.stream_nums:
            ljm.eWriteName(
                self._handle, &#34;STREAM_OUT{0}_ENABLE&#34;.format(stream_num), 1
                )

        self.stop_stream()

        if exc_type is KeyboardInterrupt:
            print(&#34;Streaming stopped by user.&#34;)
            return False

        return exc_type is None

    @classmethod
    def init_reset(cls, handle: int, out_names, in_names=None):
        &#34;&#34;&#34;Inits and resets a Streamer object.&#34;&#34;&#34;
        s = cls(handle, out_names, in_names)
        s.reset_stream()
        return s

    @property
    def out_addresses(self) -&gt; list:
        &#34;&#34;&#34;Return a list of addresses for stream-out targets.&#34;&#34;&#34;
        out_address = [
            ljm.nameToAddress(out_name)[0] for out_name in self.out_names]
        return out_address

    @property
    def stream_nums(self) -&gt; list:
        &#34;&#34;&#34;Return a list of numbers corresponding to stream-out targets.&#34;&#34;&#34;
        nums = [&#34;{0}&#34;.format(no) for no in range(len(self.out_names))]
        return nums

    @property
    def scan_list(self) -&gt; list:
        &#34;&#34;&#34;Return a list of stream-out targets for a single scan.&#34;&#34;&#34;
        scan_list = [
            ljm.nameToAddress(&#34;STREAM_OUT{0}&#34;.format(num))[0]
            for num in self.stream_nums
            ]
        return scan_list

    def reset_stream(self):
        &#34;&#34;&#34;Reset stream configurations for purely stream-out.

        Notes
        -----
        Please refer to the following links for more information on the default
        configurations:
        https://labjack.com/support/datasheets/t-series/communication/stream-mode#ain-stream
        https://labjack.com/support/datasheets/t-series/communication/stream-mode#externally-clocked
        https://labjack.com/support/datasheets/t-series/communication/stream-mode#triggered

        TODO: non-default configurations
        &#34;&#34;&#34;
        self.stop_stream()

        ljm.eWriteName(self._handle, &#34;STREAM_SETTLING_US&#34;, 0)
        ljm.eWriteName(self._handle, &#34;STREAM_RESOLUTION_INDEX&#34;, 0)
        ljm.eWriteName(self._handle, &#34;STREAM_CLOCK_SOURCE&#34;, 0)
        ljm.eWriteName(self._handle, &#34;STREAM_TRIGGER_INDEX&#34;, 0)

    def configure_stream(self, loop_num_vals: int=0):
        &#34;&#34;&#34;Configure stream-out buffer size and target and update buffer.

        What is changed?
            - setting the buffer size which must be a power of 2, max is 14 bits,
            - adding the out addresses to stream-out targets,
            - enabling a stream target so that for every scan a data value is
            taken from the available stream targets,
            - number of values from the end of the data array to repeat when
            reaching the end of the loop,
            - telling stream-out to immediate use new data loaded in

        Parameters
        ----------
        loop_num_vals : int, optional
            The number of values, from the end of the array to loop, by
            default 0.

        Notes
        -----
        Section 2 and 3 on LabJack T-series datasheets.
        &#34;&#34;&#34;
        for stream_num, out_address in zip(self.stream_nums, self.out_addresses):
            ljm.eWriteName(
                self._handle,
                &#34;STREAM_OUT{0}_BUFFER_ALLOCATE_NUM_BYTES&#34;.format(
                    stream_num), 2**14
                )
            ljm.eWriteName(
                self._handle,
                &#34;STREAM_OUT{0}_TARGET&#34;.format(stream_num), out_address
                )
            ljm.eWriteName(
                self._handle, &#34;STREAM_OUT{0}_ENABLE&#34;.format(stream_num), 1
                )
            # Update Buffer
            ljm.eWriteName(
                self._handle,
                &#34;STREAM_OUT{0}_LOOP_SIZE&#34;.format(stream_num), loop_num_vals
                )
            # This register is an alias for STREAM_OUT{0}_LOOP_NUM_VALUES
            ljm.eWriteName(
                self._handle, &#34;STREAM_OUT{0}_SET_LOOP&#34;.format(stream_num), 1
                )

    def load_data(self, datas: tuple, buffer_type: str):
        &#34;&#34;&#34;Load data array into stream-out buffer registers.

        Expecting input datas to be tuple of list or a list for a single stream out target

        Parameters
        ----------
        datas : tuple
        buffer_type : str
            Chooses whether integer or floating point data is loaded onto buffer

        Raises
        ------
        ValueError
            Invalid buffer type
        &#34;&#34;&#34;
        if isinstance(datas, tuple):
            for d in datas:
                if (
                    not isinstance(d, tuple) and
                    not isinstance(d, list) and
                    not isinstance(d, np.ndarray)):
                    raise TypeError(
                        &#34;Input data must be a tuple containing lists.&#34;
                        )

        if buffer_type == &#34;int&#34;:
            buffer_name = &#34;STREAM_OUT{0}_BUFFER_U16&#34;
        elif buffer_type == &#34;float&#34;:
            buffer_name = &#34;STREAM_OUT{0}_BUFFER_F32&#34;
        else:
            raise ValueError(
                &#34;Buffer type &#39;{0}&#39; is invalid - choose either &#39;int&#39; or &#39;float&#39;&#34;.format(
                    buffer_type
                    )
                )

        self._data_lengths = []

        for stream_num, data in zip(self.stream_nums, datas):
            ljm.eWriteNameArray(
                self._handle, buffer_name.format(stream_num), len(data), data)
            self._data_lengths.append(len(data))

    def start_stream(self, stream_time: float, scans_per_read: int=1) -&gt; float:
        &#34;&#34;&#34;Stream-out loaded data to scan list at a given scan frequency.

        Parameters
        ----------
        stream_time : float
            Total time (in s) the stream will run for, converted into scan
            rate (Hz).
        scans_per_read : int, optional
            Number of times the stream targets or scan list is scanned per
            iteration, by default 1.

        Returns
        -------
        actual_time : float
            Actual time the stream ran for which is 1.02x more than the
            predicted stream-out time.

        Raises
        ------
        ValueError
            No data loaded into Streamer, only needs to be loaded in once.
        KeyboardInterrupt
            Streaming stopped by user
        &#34;&#34;&#34;
        try:
            # determine scan rate based on loaded in data
            scan_rate = max(self._data_lengths) / stream_time
        except:
            raise ValueError(&#34;Load some data in!&#34;)


        with self:
            # stream actually starts here by setting STREAM_ENABLE=1 but doesn&#39;t
            # block execution
            actual_scan_rate = ljm.eStreamStart(
                self._handle, scans_per_read,
                len(self.scan_list), self.scan_list, scan_rate
                )
            # the sleep here is what blocks execution
            # sleeping for 2% more time than stream out time just incase
            actual_time = 1.02*(max(self._data_lengths) / actual_scan_rate)
            time.sleep(actual_time)

            return actual_time

    def stop_stream(self):
        &#34;&#34;&#34;Stop the stream.&#34;&#34;&#34;
        try:
            ljm.eStreamStop(self._handle)
        except ljm.LJMError as e:
            if e.errorString != &#34;STREAM_NOT_RUNNING&#34;:
                pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tdaq.convert_input"><code class="name flex">
<span>def <span class="ident">convert_input</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert single length input to iterable (<code>list</code> or <code>tuple</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>any type</code></dt>
<dd>Can be <code>list</code>, <code>tuple</code>, <code>numpy.ndarray</code> or any type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>iter_val</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>Iterable output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_input(val):
    &#34;&#34;&#34;Convert single length input to iterable (``list`` or ``tuple``).

    Parameters
    ----------
    val : any type
        Can be ``list``, ``tuple``, ``numpy.ndarray`` or any type.

    Returns
    -------
    iter_val : ``list`` or ``tuple``
        Iterable output.
    &#34;&#34;&#34;
    if not isinstance(val, tuple) and not isinstance(val, list):
        if isinstance(val, np.ndarray):
            # np.ndarray can only be converted to list this way
            iter_val = list(val)
        else:
            # any other variable needs this way
            iter_val = [val]
    else:
        iter_val = val
    return iter_val</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tdaq.AsynchUpdater"><code class="flex name class">
<span>class <span class="ident">AsynchUpdater</span></span>
<span>(</span><span>handle: int)</span>
</code></dt>
<dd>
<div class="desc"><p>LabJack universial asynchronous receiver-transmitter (UART) serial communication.</p>
<p>If asynchronous communication is used with the same AsynchUpdater object,
then also ensures a 50ms delay between each receive or transmit action.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>LabJack handle.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Must be either "reflow" or "machining", to set which
registers are used for asynchronous communication.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>LabJack T4/T7 UART serial communication has the same timing and protocol as
RS-232, however, the electrical specifications are different.
T4/T7:
low = 0V (0-0.5)
high = 3.3V (2.64-5.8)
RS-232:
low = 3-25V
high = -3-25V
Connection using RS-232 requires a converter chip such as MAX233.</p>
<p>For more details on UART serial communication on a LabJack, please visit:
<a href="https://labjack.com/support/datasheets/t-series/digital-io/asynchronous-serial">https://labjack.com/support/datasheets/t-series/digital-io/asynchronous-serial</a></p>
<p>Inits an AsynchUpdater object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsynchUpdater:
    &#34;&#34;&#34;LabJack universial asynchronous receiver-transmitter (UART) serial communication.

    If asynchronous communication is used with the same AsynchUpdater object,
    then also ensures a 50ms delay between each receive or transmit action.

    Parameters
    ----------
    handle : int
        LabJack handle.

    Raises
    ------
    ValueError
        Must be either &#34;reflow&#34; or &#34;machining&#34;, to set which
        registers are used for asynchronous communication.

    Notes
    -----
    LabJack T4/T7 UART serial communication has the same timing and protocol as
    RS-232, however, the electrical specifications are different.
    T4/T7:
        low = 0V (0-0.5)
        high = 3.3V (2.64-5.8)
    RS-232:
        low = 3-25V
        high = -3-25V
    Connection using RS-232 requires a converter chip such as MAX233.

    For more details on UART serial communication on a LabJack, please visit:
    https://labjack.com/support/datasheets/t-series/digital-io/asynchronous-serial
    &#34;&#34;&#34;
    min_time_interval = 50e3
    &#34;&#34;&#34;Time interval between sending commands to allow command to be received.
    Unit in μs should be 50ms&#34;&#34;&#34;

    def __init__(self, handle: int):
        &#34;&#34;&#34;Inits an AsynchUpdater object.&#34;&#34;&#34;
        self._handle = handle
        self._last_host_tick = ljm.getHostTick()

        # if experiment in ASYNCH_CONFIG_REGISTERS.keys():
        #     self.experiment = experiment
        # else:
        #     raise ValueError(&#34;Experiment &#39;{0}&#39; doesn&#39;t exist! Please choose &#39;{1}&#39; or &#39;{2}&#39;&#34;.format(experiment, *ASYNCH_CONFIG_REGISTERS.keys()))

    @property
    def _asynch_enabled(self) -&gt; bool:
        &#34;&#34;&#34;Return if asynch communications is enabled.&#34;&#34;&#34;
        enabled = bool(ljm.eReadName(self._handle, &#34;ASYNCH_ENABLE&#34;))
        return enabled

    @classmethod
    def experiment(cls, handle: int, exp_name: str):
        &#34;&#34;&#34;Inits an AsynchUpdater object and Asynch communication based on experiment.

        Raises
        ------
        ValueError
            Must be either &#34;reflow&#34; or &#34;machining&#34;, to set which registers are
            used for Asynch communication.
        &#34;&#34;&#34;
        au = cls(handle)
        if exp_name == &#34;reflow&#34;:
            reflow_asynch_conf = {
                &#34;tx&#34;:               5,
                &#34;rx&#34;:               4,
                &#34;baud&#34;:             9600,
                &#34;rx_buffer&#34;:        6,
                &#34;num_data_bits&#34;:    0,
                &#34;num_stop_bits&#34;:    1,
                &#34;parity&#34;:           0
            }
            au.init_asynch(**reflow_asynch_conf)
        elif exp_name == &#34;machining&#34;:
            machine_asynch_conf = {
                &#34;tx&#34;:               1,
                &#34;rx&#34;:               0,
                &#34;baud&#34;:             9600,
                &#34;rx_buffer&#34;:        6,
                &#34;num_data_bits&#34;:    0,
                &#34;num_stop_bits&#34;:    1,
                &#34;parity&#34;:           0
            }
            au.init_asynch(**machine_asynch_conf)
        else:
            raise ValueError(&#34;Experiment &#39;{0}&#39; doesn&#39;t exist!&#34;)
        return au

    @classmethod
    def with_configuration(cls, handle: int, **kwargs):
        &#34;&#34;&#34;Inits an AsynchUpdater object and Asynch communication configuration.

        Raises
        ------
        TypeError
            Configuration registers are not valid LabJack registers.
        &#34;&#34;&#34;
        au = cls(handle)
        try:
            au.init_asynch(**kwargs)
        except TypeError:
            raise TypeError(
                &#34;Please enter valid Asynch configuration register names.&#34;
                )
        return au

    def _check_interval(self):
        &#34;&#34;&#34;Check interval time between two asynch actions is greater than 50ms.&#34;&#34;&#34;
        # TODO: needs sleep here?
        if (ljm.getHostTick() - self._last_host_tick) &lt; self.min_time_interval:
            time.sleep(self.min_time_interval/1e6)

    def init_asynch(
        self, tx: int=0, rx: int=0, baud: int=0, rx_buffer: int=0,
        num_data_bits: int=0, num_stop_bits: int=0, parity: int=0
        ):
        &#34;&#34;&#34;Configure LabJack for Asynch communication.

        After configuring each LabJack register, ASYNCH_ENABLE is passed 1 to
        turn on Asynch communication.

        Parameters
        ----------
        tx : int, optional
            ASYNCH_TX_DIONUM, digital I/O line that transmits data, by default 0.
        rx : int, optional
            ASYNCH_RX_DIONUM, digital I/O line that receives data, by default 0.
        baud : int, optional
            ASYNCH_BAUD, symbol rate for communication, by default 0. Typical
            values are 9600 and 38600 is the maximum.
        rx_buffer : int, optional
            ASYNCH_RX_BUFFER_SIZE_BYTES, number of bytes of receiving buffer,
            by default 0. Max is 2048 and 0 = 200.
        num_data_bits : [0, 1, 2, 3, 4, 5, 6, 7, 8], optional
            ASYNCH_NUM_DATA_BITS, number of bits per frame, by default 0. 0 = 8.
        num_stop_bits : [0, 1, 2], optional
            ASYNCH_NUM_STOP_BITS, number of stop bits, by default 0.
            0 = zero stop bits,
            1 = one stop bit,
            2 = two stop bits.
        parity : [0, 1, 2], optional
            ASYNCH_PARITY, by default 0.
            0 = none,
            1 = odd,
            2 = even.
        &#34;&#34;&#34;

        if self._asynch_enabled:
            ljm.eWriteName(self._handle, &#34;ASYNCH_ENABLE&#34;, 0)

        ljm.eWriteName(self._handle, &#34;ASYNCH_TX_DIONUM&#34;, tx)
        ljm.eWriteName(self._handle, &#34;ASYNCH_RX_DIONUM&#34;, rx)
        ljm.eWriteName(self._handle, &#34;ASYNCH_BAUD&#34;, baud)
        ljm.eWriteName(self._handle, &#34;ASYNCH_RX_BUFFER_SIZE_BYTES&#34;, rx_buffer)
        ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_DATA_BITS&#34;, num_data_bits)
        ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_STOP_BITS&#34;, num_stop_bits)
        ljm.eWriteName(self._handle, &#34;ASYNCH_PARITY&#34;, parity)
        # Turn on Asynch communication
        ljm.eWriteName(self._handle, &#34;ASYNCH_ENABLE&#34;, 1)

        # reg_names = [key for key in ASYNCH_CONFIG_REGISTERS[self.experiment].keys()]
        # reg_datas = [val for val in ASYNCH_CONFIG_REGISTERS[self.experiment].values()]
        # ljm.eWriteNames(self._handle, len(reg_names), reg_names, reg_datas)

        print(&#34;Initialisation of Asynch comms. successful!&#34;)

    def transmit(self, data: list):
        &#34;&#34;&#34;Asynchronously transmit serial data to device via LabJack TX line.

        Parameters
        ----------
        data : list
            List containing serial frame message.

        TODO: check if tuple, list works - then can use same function from
        Updater
        &#34;&#34;&#34;
        self._check_interval()
        ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_BYTES_TX&#34;, len(data))
        ljm.eWriteNameArray(self._handle, &#34;ASYNCH_DATA_TX&#34;, len(data), data)
        # Initiate a transmission via the buffer
        ljm.eWriteName(self._handle, &#34;ASYNCH_TX_GO&#34;, 1)

        self._last_host_tick = ljm.getHostTick()

    def receive(self) -&gt; list:
        &#34;&#34;&#34;Asynchronously receive serial data from device via LabJack RX line.

        Returns
        -------
        asynch_rx_vals : list
            Asynch response from device via LabJack RX line.
        &#34;&#34;&#34;
        self._check_interval()
        num_rx_vals = int(ljm.eReadName(self._handle, &#34;ASYNCH_NUM_BYTES_RX&#34;))
        asynch_rx_vals = ljm.eReadNameArray(
            self._handle, &#34;ASYNCH_DATA_RX&#34;, num_rx_vals
            )
        self._last_host_tick = ljm.getHostTick()
        return asynch_rx_vals</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tdaq.AsynchUpdater.min_time_interval"><code class="name">var <span class="ident">min_time_interval</span></code></dt>
<dd>
<div class="desc"><p>Time interval between sending commands to allow command to be received.
Unit in μs should be 50ms</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tdaq.AsynchUpdater.experiment"><code class="name flex">
<span>def <span class="ident">experiment</span></span>(<span>handle: int, exp_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Inits an AsynchUpdater object and Asynch communication based on experiment.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Must be either "reflow" or "machining", to set which registers are
used for Asynch communication.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def experiment(cls, handle: int, exp_name: str):
    &#34;&#34;&#34;Inits an AsynchUpdater object and Asynch communication based on experiment.

    Raises
    ------
    ValueError
        Must be either &#34;reflow&#34; or &#34;machining&#34;, to set which registers are
        used for Asynch communication.
    &#34;&#34;&#34;
    au = cls(handle)
    if exp_name == &#34;reflow&#34;:
        reflow_asynch_conf = {
            &#34;tx&#34;:               5,
            &#34;rx&#34;:               4,
            &#34;baud&#34;:             9600,
            &#34;rx_buffer&#34;:        6,
            &#34;num_data_bits&#34;:    0,
            &#34;num_stop_bits&#34;:    1,
            &#34;parity&#34;:           0
        }
        au.init_asynch(**reflow_asynch_conf)
    elif exp_name == &#34;machining&#34;:
        machine_asynch_conf = {
            &#34;tx&#34;:               1,
            &#34;rx&#34;:               0,
            &#34;baud&#34;:             9600,
            &#34;rx_buffer&#34;:        6,
            &#34;num_data_bits&#34;:    0,
            &#34;num_stop_bits&#34;:    1,
            &#34;parity&#34;:           0
        }
        au.init_asynch(**machine_asynch_conf)
    else:
        raise ValueError(&#34;Experiment &#39;{0}&#39; doesn&#39;t exist!&#34;)
    return au</code></pre>
</details>
</dd>
<dt id="tdaq.AsynchUpdater.with_configuration"><code class="name flex">
<span>def <span class="ident">with_configuration</span></span>(<span>handle: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Inits an AsynchUpdater object and Asynch communication configuration.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Configuration registers are not valid LabJack registers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def with_configuration(cls, handle: int, **kwargs):
    &#34;&#34;&#34;Inits an AsynchUpdater object and Asynch communication configuration.

    Raises
    ------
    TypeError
        Configuration registers are not valid LabJack registers.
    &#34;&#34;&#34;
    au = cls(handle)
    try:
        au.init_asynch(**kwargs)
    except TypeError:
        raise TypeError(
            &#34;Please enter valid Asynch configuration register names.&#34;
            )
    return au</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tdaq.AsynchUpdater.init_asynch"><code class="name flex">
<span>def <span class="ident">init_asynch</span></span>(<span>self, tx: int = 0, rx: int = 0, baud: int = 0, rx_buffer: int = 0, num_data_bits: int = 0, num_stop_bits: int = 0, parity: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure LabJack for Asynch communication.</p>
<p>After configuring each LabJack register, ASYNCH_ENABLE is passed 1 to
turn on Asynch communication.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tx</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ASYNCH_TX_DIONUM, digital I/O line that transmits data, by default 0.</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ASYNCH_RX_DIONUM, digital I/O line that receives data, by default 0.</dd>
<dt><strong><code>baud</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ASYNCH_BAUD, symbol rate for communication, by default 0. Typical
values are 9600 and 38600 is the maximum.</dd>
<dt><strong><code>rx_buffer</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>ASYNCH_RX_BUFFER_SIZE_BYTES, number of bytes of receiving buffer,
by default 0. Max is 2048 and 0 = 200.</dd>
<dt><strong><code>num_data_bits</code></strong> :&ensp;<code>[0, 1, 2, 3, 4, 5, 6, 7, 8]</code>, optional</dt>
<dd>ASYNCH_NUM_DATA_BITS, number of bits per frame, by default 0. 0 = 8.</dd>
<dt><strong><code>num_stop_bits</code></strong> :&ensp;<code>[0, 1, 2]</code>, optional</dt>
<dd>ASYNCH_NUM_STOP_BITS, number of stop bits, by default 0.
0 = zero stop bits,
1 = one stop bit,
2 = two stop bits.</dd>
<dt><strong><code>parity</code></strong> :&ensp;<code>[0, 1, 2]</code>, optional</dt>
<dd>ASYNCH_PARITY, by default 0.
0 = none,
1 = odd,
2 = even.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_asynch(
    self, tx: int=0, rx: int=0, baud: int=0, rx_buffer: int=0,
    num_data_bits: int=0, num_stop_bits: int=0, parity: int=0
    ):
    &#34;&#34;&#34;Configure LabJack for Asynch communication.

    After configuring each LabJack register, ASYNCH_ENABLE is passed 1 to
    turn on Asynch communication.

    Parameters
    ----------
    tx : int, optional
        ASYNCH_TX_DIONUM, digital I/O line that transmits data, by default 0.
    rx : int, optional
        ASYNCH_RX_DIONUM, digital I/O line that receives data, by default 0.
    baud : int, optional
        ASYNCH_BAUD, symbol rate for communication, by default 0. Typical
        values are 9600 and 38600 is the maximum.
    rx_buffer : int, optional
        ASYNCH_RX_BUFFER_SIZE_BYTES, number of bytes of receiving buffer,
        by default 0. Max is 2048 and 0 = 200.
    num_data_bits : [0, 1, 2, 3, 4, 5, 6, 7, 8], optional
        ASYNCH_NUM_DATA_BITS, number of bits per frame, by default 0. 0 = 8.
    num_stop_bits : [0, 1, 2], optional
        ASYNCH_NUM_STOP_BITS, number of stop bits, by default 0.
        0 = zero stop bits,
        1 = one stop bit,
        2 = two stop bits.
    parity : [0, 1, 2], optional
        ASYNCH_PARITY, by default 0.
        0 = none,
        1 = odd,
        2 = even.
    &#34;&#34;&#34;

    if self._asynch_enabled:
        ljm.eWriteName(self._handle, &#34;ASYNCH_ENABLE&#34;, 0)

    ljm.eWriteName(self._handle, &#34;ASYNCH_TX_DIONUM&#34;, tx)
    ljm.eWriteName(self._handle, &#34;ASYNCH_RX_DIONUM&#34;, rx)
    ljm.eWriteName(self._handle, &#34;ASYNCH_BAUD&#34;, baud)
    ljm.eWriteName(self._handle, &#34;ASYNCH_RX_BUFFER_SIZE_BYTES&#34;, rx_buffer)
    ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_DATA_BITS&#34;, num_data_bits)
    ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_STOP_BITS&#34;, num_stop_bits)
    ljm.eWriteName(self._handle, &#34;ASYNCH_PARITY&#34;, parity)
    # Turn on Asynch communication
    ljm.eWriteName(self._handle, &#34;ASYNCH_ENABLE&#34;, 1)

    # reg_names = [key for key in ASYNCH_CONFIG_REGISTERS[self.experiment].keys()]
    # reg_datas = [val for val in ASYNCH_CONFIG_REGISTERS[self.experiment].values()]
    # ljm.eWriteNames(self._handle, len(reg_names), reg_names, reg_datas)

    print(&#34;Initialisation of Asynch comms. successful!&#34;)</code></pre>
</details>
</dd>
<dt id="tdaq.AsynchUpdater.receive"><code class="name flex">
<span>def <span class="ident">receive</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously receive serial data from device via LabJack RX line.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>asynch_rx_vals</code></strong> :&ensp;<code>list</code></dt>
<dd>Asynch response from device via LabJack RX line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive(self) -&gt; list:
    &#34;&#34;&#34;Asynchronously receive serial data from device via LabJack RX line.

    Returns
    -------
    asynch_rx_vals : list
        Asynch response from device via LabJack RX line.
    &#34;&#34;&#34;
    self._check_interval()
    num_rx_vals = int(ljm.eReadName(self._handle, &#34;ASYNCH_NUM_BYTES_RX&#34;))
    asynch_rx_vals = ljm.eReadNameArray(
        self._handle, &#34;ASYNCH_DATA_RX&#34;, num_rx_vals
        )
    self._last_host_tick = ljm.getHostTick()
    return asynch_rx_vals</code></pre>
</details>
</dd>
<dt id="tdaq.AsynchUpdater.transmit"><code class="name flex">
<span>def <span class="ident">transmit</span></span>(<span>self, data: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronously transmit serial data to device via LabJack TX line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>list</code></dt>
<dd>List containing serial frame message.</dd>
<dt><strong><code>TODO</code></strong> :&ensp;<code>check if tuple, list works - then can use same function from</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>Updater</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transmit(self, data: list):
    &#34;&#34;&#34;Asynchronously transmit serial data to device via LabJack TX line.

    Parameters
    ----------
    data : list
        List containing serial frame message.

    TODO: check if tuple, list works - then can use same function from
    Updater
    &#34;&#34;&#34;
    self._check_interval()
    ljm.eWriteName(self._handle, &#34;ASYNCH_NUM_BYTES_TX&#34;, len(data))
    ljm.eWriteNameArray(self._handle, &#34;ASYNCH_DATA_TX&#34;, len(data), data)
    # Initiate a transmission via the buffer
    ljm.eWriteName(self._handle, &#34;ASYNCH_TX_GO&#34;, 1)

    self._last_host_tick = ljm.getHostTick()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tdaq.Intervaler"><code class="flex name class">
<span>class <span class="ident">Intervaler</span></span>
<span>(</span><span>interval_time: float, num_iter: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up a timed interval loop using a LabJack.</p>
<p>A timed interval loop ensures that operations within the loop (before
ljm.waitForNextInterval) occurs within the specified interval time. If it
cannot, then it tries to perform the operations in the next interval and
skipped intervals are reported.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interval_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of each iteration of the interval in μs.</dd>
<dt><strong><code>num_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of iterations.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For more details about timing, refer to:
<a href="https://labjack.com/support/software/api/ljm/function-reference/timing-functions/ljmstartinterval">https://labjack.com/support/software/api/ljm/function-reference/timing-functions/ljmstartinterval</a></p>
<p>TODO: LUA scripting instead</p>
<p>Inits an Intervaler object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Intervaler:
    &#34;&#34;&#34;Sets up a timed interval loop using a LabJack.

    A timed interval loop ensures that operations within the loop (before
    ljm.waitForNextInterval) occurs within the specified interval time. If it
    cannot, then it tries to perform the operations in the next interval and
    skipped intervals are reported.

    Parameters
    ----------
    interval_time : float
        Time of each iteration of the interval in μs.
    num_iter : int
        Number of iterations.

    Notes
    -----
    For more details about timing, refer to:
    https://labjack.com/support/software/api/ljm/function-reference/timing-functions/ljmstartinterval

    TODO: LUA scripting instead
    &#34;&#34;&#34;

    def __init__(self, interval_time: float, num_iter: int):
        &#34;&#34;&#34;Inits an Intervaler object.&#34;&#34;&#34;
        # each interval has its own handle as well
        self._interval_handle = randint(1, 999)
        self.interval_time = interval_time
        self.num_iter = num_iter

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        ljm.cleanInterval(self._interval_handle)
        if exc_type is KeyboardInterrupt:
            print(&#34;Interval stopped by user.&#34;)
            return False

        return exc_type is None

    @staticmethod
    def _add_responses(resp_list: list, resp) -&gt; list:
        &#34;&#34;&#34;Either add or concatenate responses.&#34;&#34;&#34;
        if isinstance(resp, list):
            resp_list += resp
        elif resp != &#34;&#34;:
            resp_list.append(resp)
        return resp_list

    def start_interval(
        self, operations_inside, operations_outside=None,
        **operation_kwargs) -&gt; dict:
        &#34;&#34;&#34;Start a timed interval with operations inside and outside an interval.

        Functions operations_inside and operations_outside must accept as
        arguments:
            - curr_iter as an argument,
            - all of the optional operation_kwargs
        and must return
            - curr_iter as an argument (curr_iter must be incremented within
            operations_inside otherwise an infinite loop will occur
            - any read data (can be an empty string).

        Parameters
        ----------
        operations_inside : function
            Functions to execute inside a timed interval.
        operations_outside : function, optional
            Functions to execute outside a timed interval, right after the
            timed interval has finished, by default None.
        operation_kwargs : optional
            Keyword arguments for operations_inside or operations_outside,
            if requried.

        Returns
        -------
        response : dict
            Contains metrics on interval_time, total_time (total run time) and
            any responses from the LabJack.
        &#34;&#34;&#34;
        with self:
            curr_iter = 0
            all_interval_t = []
            interval_responses = []
            ljm.startInterval(self._interval_handle, self.interval_time)
            t_before_loop = ljm.getHostTick()

            while curr_iter &lt; self.num_iter:
                t_start_interval = ljm.getHostTick()
                # run the operation inside a loop, allowing operation to
                # change iteration number
                curr_iter, resp = operations_inside(
                    curr_iter, **operation_kwargs
                    )
                skipped = ljm.waitForNextInterval(self._interval_handle)
                t_end_interval = ljm.getHostTick()

                interval_responses = self._add_responses(
                    interval_responses, resp
                    )
                all_interval_t.append(t_end_interval - t_start_interval)

                if operations_outside != None:
                    # operations outside of the timed loop, called
                    # *immediately* after the timed interval has ended
                    dummy_iter, resp = operations_outside(
                        curr_iter, **operation_kwargs
                        )

                    interval_responses = self._add_responses(
                        interval_responses, resp
                        )

                if skipped &gt; 0:
                    print(&#34;Iteration {0} skipped intervals: {1}&#34;.format(
                        curr_iter, skipped
                        ))

            total_time = ljm.getHostTick() - t_before_loop
            # Context manager handles cleaning the interval already
            # ljm.cleanInterval(self._interval_handle)

            response = {
                &#34;interval_time&#34;: np.mean(all_interval_t),
                &#34;total_time&#34;: total_time,
                &#34;response&#34;: interval_responses
            }

            return response</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tdaq.Intervaler.start_interval"><code class="name flex">
<span>def <span class="ident">start_interval</span></span>(<span>self, operations_inside, operations_outside=None, **operation_kwargs) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Start a timed interval with operations inside and outside an interval.</p>
<p>Functions operations_inside and operations_outside must accept as
arguments:
- curr_iter as an argument,
- all of the optional operation_kwargs
and must return
- curr_iter as an argument (curr_iter must be incremented within
operations_inside otherwise an infinite loop will occur
- any read data (can be an empty string).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>operations_inside</code></strong> :&ensp;<code>function</code></dt>
<dd>Functions to execute inside a timed interval.</dd>
<dt><strong><code>operations_outside</code></strong> :&ensp;<code>function</code>, optional</dt>
<dd>Functions to execute outside a timed interval, right after the
timed interval has finished, by default None.</dd>
<dt><strong><code>operation_kwargs</code></strong> :&ensp;<code>optional</code></dt>
<dd>Keyword arguments for operations_inside or operations_outside,
if requried.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>response</code></strong> :&ensp;<code>dict</code></dt>
<dd>Contains metrics on interval_time, total_time (total run time) and
any responses from the LabJack.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_interval(
    self, operations_inside, operations_outside=None,
    **operation_kwargs) -&gt; dict:
    &#34;&#34;&#34;Start a timed interval with operations inside and outside an interval.

    Functions operations_inside and operations_outside must accept as
    arguments:
        - curr_iter as an argument,
        - all of the optional operation_kwargs
    and must return
        - curr_iter as an argument (curr_iter must be incremented within
        operations_inside otherwise an infinite loop will occur
        - any read data (can be an empty string).

    Parameters
    ----------
    operations_inside : function
        Functions to execute inside a timed interval.
    operations_outside : function, optional
        Functions to execute outside a timed interval, right after the
        timed interval has finished, by default None.
    operation_kwargs : optional
        Keyword arguments for operations_inside or operations_outside,
        if requried.

    Returns
    -------
    response : dict
        Contains metrics on interval_time, total_time (total run time) and
        any responses from the LabJack.
    &#34;&#34;&#34;
    with self:
        curr_iter = 0
        all_interval_t = []
        interval_responses = []
        ljm.startInterval(self._interval_handle, self.interval_time)
        t_before_loop = ljm.getHostTick()

        while curr_iter &lt; self.num_iter:
            t_start_interval = ljm.getHostTick()
            # run the operation inside a loop, allowing operation to
            # change iteration number
            curr_iter, resp = operations_inside(
                curr_iter, **operation_kwargs
                )
            skipped = ljm.waitForNextInterval(self._interval_handle)
            t_end_interval = ljm.getHostTick()

            interval_responses = self._add_responses(
                interval_responses, resp
                )
            all_interval_t.append(t_end_interval - t_start_interval)

            if operations_outside != None:
                # operations outside of the timed loop, called
                # *immediately* after the timed interval has ended
                dummy_iter, resp = operations_outside(
                    curr_iter, **operation_kwargs
                    )

                interval_responses = self._add_responses(
                    interval_responses, resp
                    )

            if skipped &gt; 0:
                print(&#34;Iteration {0} skipped intervals: {1}&#34;.format(
                    curr_iter, skipped
                    ))

        total_time = ljm.getHostTick() - t_before_loop
        # Context manager handles cleaning the interval already
        # ljm.cleanInterval(self._interval_handle)

        response = {
            &#34;interval_time&#34;: np.mean(all_interval_t),
            &#34;total_time&#34;: total_time,
            &#34;response&#34;: interval_responses
        }

        return response</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tdaq.LabJackDaq"><code class="flex name class">
<span>class <span class="ident">LabJackDaq</span></span>
<span>(</span><span>device_type='ANY', connection_type='ANY', identifier='ANY')</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for LabJack LJM library, to execute read and write timings and data loading.</p>
<p>Written for T-Series products such as the T4 and T7.</p>
<p>The handle and <code><a title="tdaq.Updater" href="#tdaq.Updater">Updater</a></code>, <code><a title="tdaq.AsynchUpdater" href="#tdaq.AsynchUpdater">AsynchUpdater</a></code>, <code><a title="tdaq.Intervaler" href="#tdaq.Intervaler">Intervaler</a></code>, and
<code><a title="tdaq.Streamer" href="#tdaq.Streamer">Streamer</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device_type</code></strong> :&ensp;<code>str</code></dt>
<dd>From LJM docs: A string containing the type of the device to be
connected, optionally prepended by "LJM_dt". Possible values include
"ANY", "T4", "T7", and "DIGIT".</dd>
<dt><strong><code>connection_type</code></strong> :&ensp;<code>str</code></dt>
<dd>From LJM docs: A string containing the type of the connection desired,
optionally prepended by "LJM_ct". Possible values include "ANY", "USB",
"TCP", "ETHERNET", and "WIFI".</dd>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>From LJM docs: A string identifying the device to be connected or
"LJM_idANY"/"ANY". This can be a serial number, IP address, or device
name. Device names may not contain periods.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Please refer to the following links for more details:
<a href="https://labjack.com/support/datasheets/t-series">https://labjack.com/support/datasheets/t-series</a>
<a href="https://labjack.com/support/datasheets/t-series/communication/modbus-map">https://labjack.com/support/datasheets/t-series/communication/modbus-map</a>
<a href="https://labjack.com/support/software/api/ljm">https://labjack.com/support/software/api/ljm</a></p>
<p>Init a LabJackControl object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabJackDaq:
    &#34;&#34;&#34;Wrapper for LabJack LJM library, to execute read and write timings and data loading.

    Written for T-Series products such as the T4 and T7.

    The handle and ``Updater``, ``AsynchUpdater``, ``Intervaler``, and
    ``Streamer``.

    Parameters
    ----------
    device_type : str
        From LJM docs: A string containing the type of the device to be
        connected, optionally prepended by &#34;LJM_dt&#34;. Possible values include
        &#34;ANY&#34;, &#34;T4&#34;, &#34;T7&#34;, and &#34;DIGIT&#34;.
    connection_type : str
        From LJM docs: A string containing the type of the connection desired,
        optionally prepended by &#34;LJM_ct&#34;. Possible values include &#34;ANY&#34;, &#34;USB&#34;,
        &#34;TCP&#34;, &#34;ETHERNET&#34;, and &#34;WIFI&#34;.
    identifier : str
        From LJM docs: A string identifying the device to be connected or
        &#34;LJM_idANY&#34;/&#34;ANY&#34;. This can be a serial number, IP address, or device
        name. Device names may not contain periods.

    Notes
    -----
    Please refer to the following links for more details:
    https://labjack.com/support/datasheets/t-series
    https://labjack.com/support/datasheets/t-series/communication/modbus-map
    https://labjack.com/support/software/api/ljm
    &#34;&#34;&#34;
    def __init__(
        self, device_type=&#34;ANY&#34;, connection_type=&#34;ANY&#34;, identifier=&#34;ANY&#34;):
        &#34;&#34;&#34;Init a LabJackControl object.&#34;&#34;&#34;
        self.handle = ljm.openS(device_type, connection_type, identifier)
        print(
            &#34;Device type: {0}, connection type: {1}, ID: {2}, IP: {3}, port: {4}, Max {5} MB per packet&#34;.format(
                *ljm.getHandleInfo(self.handle)
                )
            )
        # TODO: error handling

    @classmethod
    def experiment(cls, exp_name: str):
        &#34;&#34;&#34;Init a LabJack object and other components based on experiment name.&#34;&#34;&#34;
        if exp_name == &#34;reflow&#34;:
            lj = cls(device_type=&#34;T4&#34;)
            lj.add_asynch(exp_name)
        elif exp_name == &#34;machining&#34;:
            lj = cls(device_type=&#34;T7&#34;)
            lj.add_asynch(exp_name)
            lj.add_update(
                write_names=[&#34;DAC0_BINARY&#34;, &#34;DAC1_BINARY&#34;],
                read_names=[&#34;DAC0&#34;, &#34;DAC1&#34;]
                )
            lj.add_stream_out(out_names=[&#34;DAC0&#34;, &#34;DAC1&#34;])
        else:
            raise ValueError(&#34;Please choose a valid experiment name.&#34;)
        return lj

    def close(self):
        &#34;&#34;&#34;Close connection between host and LabJack.&#34;&#34;&#34;
        try:
            ljm.close(self.handle)
        except ljm.LJMError as e:
            if e.errorString != &#34;LJME_DEVICE_NOT_OPEN&#34;:
                raise ljm.LJMError(&#34;Cannot close LabJack - unsure why.&#34;)

    def add_update(self, write_names, read_names):
        &#34;&#34;&#34;Add an ``Updater``, refer to the class for more info.&#34;&#34;&#34;
        self.update = Updater(self.handle, write_names, read_names)

    def add_stream_out(self, out_names, in_names=None):
        &#34;&#34;&#34;Add a ``Streamer``, refer to the class for more info.&#34;&#34;&#34;
        self.stream_out = Streamer.init_reset(
            self.handle, out_names, in_names=in_names
            )

    def add_asynch(self, exp_name: str):
        &#34;&#34;&#34;Add a ``AsynchUpdater``, refer to the class for more info.&#34;&#34;&#34;
        self.asynch = AsynchUpdater.experiment(self.handle, exp_name=exp_name)

    def add_interval(self, interval_time: float, num_iter: int):
        &#34;&#34;&#34;Add a ``Intervaler``, refer to the class for more info.&#34;&#34;&#34;
        self.interval = Intervaler(interval_time, num_iter)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tdaq.LabJackDaq.experiment"><code class="name flex">
<span>def <span class="ident">experiment</span></span>(<span>exp_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Init a LabJack object and other components based on experiment name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def experiment(cls, exp_name: str):
    &#34;&#34;&#34;Init a LabJack object and other components based on experiment name.&#34;&#34;&#34;
    if exp_name == &#34;reflow&#34;:
        lj = cls(device_type=&#34;T4&#34;)
        lj.add_asynch(exp_name)
    elif exp_name == &#34;machining&#34;:
        lj = cls(device_type=&#34;T7&#34;)
        lj.add_asynch(exp_name)
        lj.add_update(
            write_names=[&#34;DAC0_BINARY&#34;, &#34;DAC1_BINARY&#34;],
            read_names=[&#34;DAC0&#34;, &#34;DAC1&#34;]
            )
        lj.add_stream_out(out_names=[&#34;DAC0&#34;, &#34;DAC1&#34;])
    else:
        raise ValueError(&#34;Please choose a valid experiment name.&#34;)
    return lj</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tdaq.LabJackDaq.add_asynch"><code class="name flex">
<span>def <span class="ident">add_asynch</span></span>(<span>self, exp_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a <code><a title="tdaq.AsynchUpdater" href="#tdaq.AsynchUpdater">AsynchUpdater</a></code>, refer to the class for more info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_asynch(self, exp_name: str):
    &#34;&#34;&#34;Add a ``AsynchUpdater``, refer to the class for more info.&#34;&#34;&#34;
    self.asynch = AsynchUpdater.experiment(self.handle, exp_name=exp_name)</code></pre>
</details>
</dd>
<dt id="tdaq.LabJackDaq.add_interval"><code class="name flex">
<span>def <span class="ident">add_interval</span></span>(<span>self, interval_time: float, num_iter: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a <code><a title="tdaq.Intervaler" href="#tdaq.Intervaler">Intervaler</a></code>, refer to the class for more info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_interval(self, interval_time: float, num_iter: int):
    &#34;&#34;&#34;Add a ``Intervaler``, refer to the class for more info.&#34;&#34;&#34;
    self.interval = Intervaler(interval_time, num_iter)</code></pre>
</details>
</dd>
<dt id="tdaq.LabJackDaq.add_stream_out"><code class="name flex">
<span>def <span class="ident">add_stream_out</span></span>(<span>self, out_names, in_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a <code><a title="tdaq.Streamer" href="#tdaq.Streamer">Streamer</a></code>, refer to the class for more info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_stream_out(self, out_names, in_names=None):
    &#34;&#34;&#34;Add a ``Streamer``, refer to the class for more info.&#34;&#34;&#34;
    self.stream_out = Streamer.init_reset(
        self.handle, out_names, in_names=in_names
        )</code></pre>
</details>
</dd>
<dt id="tdaq.LabJackDaq.add_update"><code class="name flex">
<span>def <span class="ident">add_update</span></span>(<span>self, write_names, read_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an <code><a title="tdaq.Updater" href="#tdaq.Updater">Updater</a></code>, refer to the class for more info.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_update(self, write_names, read_names):
    &#34;&#34;&#34;Add an ``Updater``, refer to the class for more info.&#34;&#34;&#34;
    self.update = Updater(self.handle, write_names, read_names)</code></pre>
</details>
</dd>
<dt id="tdaq.LabJackDaq.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close connection between host and LabJack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close connection between host and LabJack.&#34;&#34;&#34;
    try:
        ljm.close(self.handle)
    except ljm.LJMError as e:
        if e.errorString != &#34;LJME_DEVICE_NOT_OPEN&#34;:
            raise ljm.LJMError(&#34;Cannot close LabJack - unsure why.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tdaq.Streamer"><code class="flex name class">
<span>class <span class="ident">Streamer</span></span>
<span>(</span><span>handle: int, out_names, in_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Streaming data from buffer to output mode via the LabJack.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>LabJack handle.</dd>
<dt><strong><code>out_names</code></strong> :&ensp;<code>any</code></dt>
<dd>List of register names for stream-out.</dd>
<dt><strong><code>in_names</code></strong> :&ensp;<code>any</code>, optional</dt>
<dd>NotImplemented, by default None</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Please refer to the following links for further details on the registers:
<a href="https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out">https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out</a>
<a href="https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out/stream-out-description">https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out/stream-out-description</a></p>
<p>Inits a Streamer object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Streamer:
    &#34;&#34;&#34;Streaming data from buffer to output mode via the LabJack.

    Parameters
    ----------
    handle : int
        LabJack handle.
    out_names : any
        List of register names for stream-out.
    in_names : any, optional
        NotImplemented, by default None

    Notes
    -----
    Please refer to the following links for further details on the registers:
    https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out
    https://labjack.com/support/datasheets/t-series/communication/stream-mode/stream-out/stream-out-description
    &#34;&#34;&#34;

    def __init__(self, handle: int, out_names, in_names=None):
        &#34;&#34;&#34;Inits a Streamer object.&#34;&#34;&#34;
        self._handle = handle

        self.out_names = convert_input(out_names)
        self.in_names = in_names    # Not yet implemented

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        for stream_num in self.stream_nums:
            ljm.eWriteName(
                self._handle, &#34;STREAM_OUT{0}_ENABLE&#34;.format(stream_num), 1
                )

        self.stop_stream()

        if exc_type is KeyboardInterrupt:
            print(&#34;Streaming stopped by user.&#34;)
            return False

        return exc_type is None

    @classmethod
    def init_reset(cls, handle: int, out_names, in_names=None):
        &#34;&#34;&#34;Inits and resets a Streamer object.&#34;&#34;&#34;
        s = cls(handle, out_names, in_names)
        s.reset_stream()
        return s

    @property
    def out_addresses(self) -&gt; list:
        &#34;&#34;&#34;Return a list of addresses for stream-out targets.&#34;&#34;&#34;
        out_address = [
            ljm.nameToAddress(out_name)[0] for out_name in self.out_names]
        return out_address

    @property
    def stream_nums(self) -&gt; list:
        &#34;&#34;&#34;Return a list of numbers corresponding to stream-out targets.&#34;&#34;&#34;
        nums = [&#34;{0}&#34;.format(no) for no in range(len(self.out_names))]
        return nums

    @property
    def scan_list(self) -&gt; list:
        &#34;&#34;&#34;Return a list of stream-out targets for a single scan.&#34;&#34;&#34;
        scan_list = [
            ljm.nameToAddress(&#34;STREAM_OUT{0}&#34;.format(num))[0]
            for num in self.stream_nums
            ]
        return scan_list

    def reset_stream(self):
        &#34;&#34;&#34;Reset stream configurations for purely stream-out.

        Notes
        -----
        Please refer to the following links for more information on the default
        configurations:
        https://labjack.com/support/datasheets/t-series/communication/stream-mode#ain-stream
        https://labjack.com/support/datasheets/t-series/communication/stream-mode#externally-clocked
        https://labjack.com/support/datasheets/t-series/communication/stream-mode#triggered

        TODO: non-default configurations
        &#34;&#34;&#34;
        self.stop_stream()

        ljm.eWriteName(self._handle, &#34;STREAM_SETTLING_US&#34;, 0)
        ljm.eWriteName(self._handle, &#34;STREAM_RESOLUTION_INDEX&#34;, 0)
        ljm.eWriteName(self._handle, &#34;STREAM_CLOCK_SOURCE&#34;, 0)
        ljm.eWriteName(self._handle, &#34;STREAM_TRIGGER_INDEX&#34;, 0)

    def configure_stream(self, loop_num_vals: int=0):
        &#34;&#34;&#34;Configure stream-out buffer size and target and update buffer.

        What is changed?
            - setting the buffer size which must be a power of 2, max is 14 bits,
            - adding the out addresses to stream-out targets,
            - enabling a stream target so that for every scan a data value is
            taken from the available stream targets,
            - number of values from the end of the data array to repeat when
            reaching the end of the loop,
            - telling stream-out to immediate use new data loaded in

        Parameters
        ----------
        loop_num_vals : int, optional
            The number of values, from the end of the array to loop, by
            default 0.

        Notes
        -----
        Section 2 and 3 on LabJack T-series datasheets.
        &#34;&#34;&#34;
        for stream_num, out_address in zip(self.stream_nums, self.out_addresses):
            ljm.eWriteName(
                self._handle,
                &#34;STREAM_OUT{0}_BUFFER_ALLOCATE_NUM_BYTES&#34;.format(
                    stream_num), 2**14
                )
            ljm.eWriteName(
                self._handle,
                &#34;STREAM_OUT{0}_TARGET&#34;.format(stream_num), out_address
                )
            ljm.eWriteName(
                self._handle, &#34;STREAM_OUT{0}_ENABLE&#34;.format(stream_num), 1
                )
            # Update Buffer
            ljm.eWriteName(
                self._handle,
                &#34;STREAM_OUT{0}_LOOP_SIZE&#34;.format(stream_num), loop_num_vals
                )
            # This register is an alias for STREAM_OUT{0}_LOOP_NUM_VALUES
            ljm.eWriteName(
                self._handle, &#34;STREAM_OUT{0}_SET_LOOP&#34;.format(stream_num), 1
                )

    def load_data(self, datas: tuple, buffer_type: str):
        &#34;&#34;&#34;Load data array into stream-out buffer registers.

        Expecting input datas to be tuple of list or a list for a single stream out target

        Parameters
        ----------
        datas : tuple
        buffer_type : str
            Chooses whether integer or floating point data is loaded onto buffer

        Raises
        ------
        ValueError
            Invalid buffer type
        &#34;&#34;&#34;
        if isinstance(datas, tuple):
            for d in datas:
                if (
                    not isinstance(d, tuple) and
                    not isinstance(d, list) and
                    not isinstance(d, np.ndarray)):
                    raise TypeError(
                        &#34;Input data must be a tuple containing lists.&#34;
                        )

        if buffer_type == &#34;int&#34;:
            buffer_name = &#34;STREAM_OUT{0}_BUFFER_U16&#34;
        elif buffer_type == &#34;float&#34;:
            buffer_name = &#34;STREAM_OUT{0}_BUFFER_F32&#34;
        else:
            raise ValueError(
                &#34;Buffer type &#39;{0}&#39; is invalid - choose either &#39;int&#39; or &#39;float&#39;&#34;.format(
                    buffer_type
                    )
                )

        self._data_lengths = []

        for stream_num, data in zip(self.stream_nums, datas):
            ljm.eWriteNameArray(
                self._handle, buffer_name.format(stream_num), len(data), data)
            self._data_lengths.append(len(data))

    def start_stream(self, stream_time: float, scans_per_read: int=1) -&gt; float:
        &#34;&#34;&#34;Stream-out loaded data to scan list at a given scan frequency.

        Parameters
        ----------
        stream_time : float
            Total time (in s) the stream will run for, converted into scan
            rate (Hz).
        scans_per_read : int, optional
            Number of times the stream targets or scan list is scanned per
            iteration, by default 1.

        Returns
        -------
        actual_time : float
            Actual time the stream ran for which is 1.02x more than the
            predicted stream-out time.

        Raises
        ------
        ValueError
            No data loaded into Streamer, only needs to be loaded in once.
        KeyboardInterrupt
            Streaming stopped by user
        &#34;&#34;&#34;
        try:
            # determine scan rate based on loaded in data
            scan_rate = max(self._data_lengths) / stream_time
        except:
            raise ValueError(&#34;Load some data in!&#34;)


        with self:
            # stream actually starts here by setting STREAM_ENABLE=1 but doesn&#39;t
            # block execution
            actual_scan_rate = ljm.eStreamStart(
                self._handle, scans_per_read,
                len(self.scan_list), self.scan_list, scan_rate
                )
            # the sleep here is what blocks execution
            # sleeping for 2% more time than stream out time just incase
            actual_time = 1.02*(max(self._data_lengths) / actual_scan_rate)
            time.sleep(actual_time)

            return actual_time

    def stop_stream(self):
        &#34;&#34;&#34;Stop the stream.&#34;&#34;&#34;
        try:
            ljm.eStreamStop(self._handle)
        except ljm.LJMError as e:
            if e.errorString != &#34;STREAM_NOT_RUNNING&#34;:
                pass</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tdaq.Streamer.init_reset"><code class="name flex">
<span>def <span class="ident">init_reset</span></span>(<span>handle: int, out_names, in_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Inits and resets a Streamer object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def init_reset(cls, handle: int, out_names, in_names=None):
    &#34;&#34;&#34;Inits and resets a Streamer object.&#34;&#34;&#34;
    s = cls(handle, out_names, in_names)
    s.reset_stream()
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tdaq.Streamer.out_addresses"><code class="name">var <span class="ident">out_addresses</span> : list</code></dt>
<dd>
<div class="desc"><p>Return a list of addresses for stream-out targets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def out_addresses(self) -&gt; list:
    &#34;&#34;&#34;Return a list of addresses for stream-out targets.&#34;&#34;&#34;
    out_address = [
        ljm.nameToAddress(out_name)[0] for out_name in self.out_names]
    return out_address</code></pre>
</details>
</dd>
<dt id="tdaq.Streamer.scan_list"><code class="name">var <span class="ident">scan_list</span> : list</code></dt>
<dd>
<div class="desc"><p>Return a list of stream-out targets for a single scan.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scan_list(self) -&gt; list:
    &#34;&#34;&#34;Return a list of stream-out targets for a single scan.&#34;&#34;&#34;
    scan_list = [
        ljm.nameToAddress(&#34;STREAM_OUT{0}&#34;.format(num))[0]
        for num in self.stream_nums
        ]
    return scan_list</code></pre>
</details>
</dd>
<dt id="tdaq.Streamer.stream_nums"><code class="name">var <span class="ident">stream_nums</span> : list</code></dt>
<dd>
<div class="desc"><p>Return a list of numbers corresponding to stream-out targets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stream_nums(self) -&gt; list:
    &#34;&#34;&#34;Return a list of numbers corresponding to stream-out targets.&#34;&#34;&#34;
    nums = [&#34;{0}&#34;.format(no) for no in range(len(self.out_names))]
    return nums</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tdaq.Streamer.configure_stream"><code class="name flex">
<span>def <span class="ident">configure_stream</span></span>(<span>self, loop_num_vals: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure stream-out buffer size and target and update buffer.</p>
<p>What is changed?
- setting the buffer size which must be a power of 2, max is 14 bits,
- adding the out addresses to stream-out targets,
- enabling a stream target so that for every scan a data value is
taken from the available stream targets,
- number of values from the end of the data array to repeat when
reaching the end of the loop,
- telling stream-out to immediate use new data loaded in</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loop_num_vals</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of values, from the end of the array to loop, by
default 0.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Section 2 and 3 on LabJack T-series datasheets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_stream(self, loop_num_vals: int=0):
    &#34;&#34;&#34;Configure stream-out buffer size and target and update buffer.

    What is changed?
        - setting the buffer size which must be a power of 2, max is 14 bits,
        - adding the out addresses to stream-out targets,
        - enabling a stream target so that for every scan a data value is
        taken from the available stream targets,
        - number of values from the end of the data array to repeat when
        reaching the end of the loop,
        - telling stream-out to immediate use new data loaded in

    Parameters
    ----------
    loop_num_vals : int, optional
        The number of values, from the end of the array to loop, by
        default 0.

    Notes
    -----
    Section 2 and 3 on LabJack T-series datasheets.
    &#34;&#34;&#34;
    for stream_num, out_address in zip(self.stream_nums, self.out_addresses):
        ljm.eWriteName(
            self._handle,
            &#34;STREAM_OUT{0}_BUFFER_ALLOCATE_NUM_BYTES&#34;.format(
                stream_num), 2**14
            )
        ljm.eWriteName(
            self._handle,
            &#34;STREAM_OUT{0}_TARGET&#34;.format(stream_num), out_address
            )
        ljm.eWriteName(
            self._handle, &#34;STREAM_OUT{0}_ENABLE&#34;.format(stream_num), 1
            )
        # Update Buffer
        ljm.eWriteName(
            self._handle,
            &#34;STREAM_OUT{0}_LOOP_SIZE&#34;.format(stream_num), loop_num_vals
            )
        # This register is an alias for STREAM_OUT{0}_LOOP_NUM_VALUES
        ljm.eWriteName(
            self._handle, &#34;STREAM_OUT{0}_SET_LOOP&#34;.format(stream_num), 1
            )</code></pre>
</details>
</dd>
<dt id="tdaq.Streamer.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, datas: tuple, buffer_type: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load data array into stream-out buffer registers.</p>
<p>Expecting input datas to be tuple of list or a list for a single stream out target</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datas</code></strong> :&ensp;<code>tuple</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>buffer_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Chooses whether integer or floating point data is loaded onto buffer</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid buffer type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(self, datas: tuple, buffer_type: str):
    &#34;&#34;&#34;Load data array into stream-out buffer registers.

    Expecting input datas to be tuple of list or a list for a single stream out target

    Parameters
    ----------
    datas : tuple
    buffer_type : str
        Chooses whether integer or floating point data is loaded onto buffer

    Raises
    ------
    ValueError
        Invalid buffer type
    &#34;&#34;&#34;
    if isinstance(datas, tuple):
        for d in datas:
            if (
                not isinstance(d, tuple) and
                not isinstance(d, list) and
                not isinstance(d, np.ndarray)):
                raise TypeError(
                    &#34;Input data must be a tuple containing lists.&#34;
                    )

    if buffer_type == &#34;int&#34;:
        buffer_name = &#34;STREAM_OUT{0}_BUFFER_U16&#34;
    elif buffer_type == &#34;float&#34;:
        buffer_name = &#34;STREAM_OUT{0}_BUFFER_F32&#34;
    else:
        raise ValueError(
            &#34;Buffer type &#39;{0}&#39; is invalid - choose either &#39;int&#39; or &#39;float&#39;&#34;.format(
                buffer_type
                )
            )

    self._data_lengths = []

    for stream_num, data in zip(self.stream_nums, datas):
        ljm.eWriteNameArray(
            self._handle, buffer_name.format(stream_num), len(data), data)
        self._data_lengths.append(len(data))</code></pre>
</details>
</dd>
<dt id="tdaq.Streamer.reset_stream"><code class="name flex">
<span>def <span class="ident">reset_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset stream configurations for purely stream-out.</p>
<h2 id="notes">Notes</h2>
<p>Please refer to the following links for more information on the default
configurations:
<a href="https://labjack.com/support/datasheets/t-series/communication/stream-mode#ain-stream">https://labjack.com/support/datasheets/t-series/communication/stream-mode#ain-stream</a>
<a href="https://labjack.com/support/datasheets/t-series/communication/stream-mode#externally-clocked">https://labjack.com/support/datasheets/t-series/communication/stream-mode#externally-clocked</a>
<a href="https://labjack.com/support/datasheets/t-series/communication/stream-mode#triggered">https://labjack.com/support/datasheets/t-series/communication/stream-mode#triggered</a></p>
<p>TODO: non-default configurations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_stream(self):
    &#34;&#34;&#34;Reset stream configurations for purely stream-out.

    Notes
    -----
    Please refer to the following links for more information on the default
    configurations:
    https://labjack.com/support/datasheets/t-series/communication/stream-mode#ain-stream
    https://labjack.com/support/datasheets/t-series/communication/stream-mode#externally-clocked
    https://labjack.com/support/datasheets/t-series/communication/stream-mode#triggered

    TODO: non-default configurations
    &#34;&#34;&#34;
    self.stop_stream()

    ljm.eWriteName(self._handle, &#34;STREAM_SETTLING_US&#34;, 0)
    ljm.eWriteName(self._handle, &#34;STREAM_RESOLUTION_INDEX&#34;, 0)
    ljm.eWriteName(self._handle, &#34;STREAM_CLOCK_SOURCE&#34;, 0)
    ljm.eWriteName(self._handle, &#34;STREAM_TRIGGER_INDEX&#34;, 0)</code></pre>
</details>
</dd>
<dt id="tdaq.Streamer.start_stream"><code class="name flex">
<span>def <span class="ident">start_stream</span></span>(<span>self, stream_time: float, scans_per_read: int = 1) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Stream-out loaded data to scan list at a given scan frequency.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stream_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Total time (in s) the stream will run for, converted into scan
rate (Hz).</dd>
<dt><strong><code>scans_per_read</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of times the stream targets or scan list is scanned per
iteration, by default 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>actual_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Actual time the stream ran for which is 1.02x more than the
predicted stream-out time.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No data loaded into Streamer, only needs to be loaded in once.</dd>
<dt><code>KeyboardInterrupt</code></dt>
<dd>Streaming stopped by user</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_stream(self, stream_time: float, scans_per_read: int=1) -&gt; float:
    &#34;&#34;&#34;Stream-out loaded data to scan list at a given scan frequency.

    Parameters
    ----------
    stream_time : float
        Total time (in s) the stream will run for, converted into scan
        rate (Hz).
    scans_per_read : int, optional
        Number of times the stream targets or scan list is scanned per
        iteration, by default 1.

    Returns
    -------
    actual_time : float
        Actual time the stream ran for which is 1.02x more than the
        predicted stream-out time.

    Raises
    ------
    ValueError
        No data loaded into Streamer, only needs to be loaded in once.
    KeyboardInterrupt
        Streaming stopped by user
    &#34;&#34;&#34;
    try:
        # determine scan rate based on loaded in data
        scan_rate = max(self._data_lengths) / stream_time
    except:
        raise ValueError(&#34;Load some data in!&#34;)


    with self:
        # stream actually starts here by setting STREAM_ENABLE=1 but doesn&#39;t
        # block execution
        actual_scan_rate = ljm.eStreamStart(
            self._handle, scans_per_read,
            len(self.scan_list), self.scan_list, scan_rate
            )
        # the sleep here is what blocks execution
        # sleeping for 2% more time than stream out time just incase
        actual_time = 1.02*(max(self._data_lengths) / actual_scan_rate)
        time.sleep(actual_time)

        return actual_time</code></pre>
</details>
</dd>
<dt id="tdaq.Streamer.stop_stream"><code class="name flex">
<span>def <span class="ident">stop_stream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the stream.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_stream(self):
    &#34;&#34;&#34;Stop the stream.&#34;&#34;&#34;
    try:
        ljm.eStreamStop(self._handle)
    except ljm.LJMError as e:
        if e.errorString != &#34;STREAM_NOT_RUNNING&#34;:
            pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tdaq.Updater"><code class="flex name class">
<span>class <span class="ident">Updater</span></span>
<span>(</span><span>handle: int, write_names, read_names)</span>
</code></dt>
<dd>
<div class="desc"><p>LabJack reader and writer to registers.</p>
<p>Read and write registers can be the same or different.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>handle</code></strong> :&ensp;<code>int</code></dt>
<dd>Labjack handle.</dd>
<dt><strong><code>write_names</code></strong> :&ensp;<code>list, tuple,</code> or <code>str</code></dt>
<dd>Write register names.</dd>
<dt><strong><code>read_names</code></strong> :&ensp;<code>list, tuple</code> or <code>str</code></dt>
<dd>Read register names.</dd>
</dl>
<p>Inits an Updater object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Updater:
    &#34;&#34;&#34;LabJack reader and writer to registers.

    Read and write registers can be the same or different.

    Parameters
    ----------
    handle : int
        Labjack handle.
    write_names : list, tuple, or str
        Write register names.
    read_names : list, tuple or str
        Read register names.

    &#34;&#34;&#34;

    def __init__(self, handle: int, write_names, read_names):
        &#34;&#34;&#34;Inits an Updater object.&#34;&#34;&#34;
        self._handle = handle

        self.write_names = convert_input(write_names)
        self.read_names = convert_input(read_names)

    @classmethod
    def same_registers(cls, handle: int, reg_names):
        &#34;&#34;&#34;Inits an Updater object with the same read and write registers.&#34;&#34;&#34;
        return cls(handle, reg_names, reg_names)

    @property
    def same_registers(self) -&gt; bool:
        &#34;&#34;&#34;Checks if the read and write registers are the same.&#34;&#34;&#34;
        same = set(self.write_names) == set(self.read_names)
        return same

    def read(self) -&gt; dict:
        &#34;&#34;&#34;Read from Labjack registers.

        Returns
        -------
        read_dict : dict
            Dict in the format ``{register_name : data}``.
        &#34;&#34;&#34;
        read_data = ljm.eReadNames(
            self._handle, len(self.read_names), self.read_names
            )
        read_dict = {
            name: data for name, data in zip(self.read_names, read_data)
            }
        return read_dict

    def write(self, datas):
        &#34;&#34;&#34;Write to Labjack registers with input data.

        Parameters
        ----------
        datas : tuple, list or anything
        &#34;&#34;&#34;
        # Single-valued data is converted into a list
        iter_datas = convert_input(datas)

        if len(iter_datas) != len(self.write_names):
            raise ValueError

        ljm.eWriteNames(
            self._handle, len(self.write_names), self.write_names, iter_datas
            )

    def update(self, datas) -&gt; dict:
        &#34;&#34;&#34;Write to and read from Labjack.

        If read and write registers are different then reads from
        object-defined read registers.

        Parameters
        ----------
        datas : tuple, list or anything
            Input data.

        Returns
        -------
        read_dict : dict
            See ``Updater.read``.

        Raises
        ------
        ValueError
            Length of data to write doesn&#39;t match number of write registers.
        &#34;&#34;&#34;
        # ljm.eReadNames only works with list/tuple names so must be converted
        iter_datas = convert_input(datas)

        if len(iter_datas) != len(self.write_names):
            raise ValueError(
                &#34;Length of data to write doesn&#39;t match number of write registers&#34;
                )

        ljm.eWriteNames(
            self._handle, len(self.write_names), self.write_names, iter_datas
            )

        if self.same_registers:
            # Read the same registers after writing to them.
            read_data = ljm.eReadNames(
                self._handle, len(self.write_names), self.write_names
                )
            read_dict = {
                name: data for name, data in zip(self.write_names, read_data)
                }
        else:
            read_dict = self.read()

        return read_dict</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tdaq.Updater.same_registers"><code class="name">var <span class="ident">same_registers</span> : bool</code></dt>
<dd>
<div class="desc"><p>Checks if the read and write registers are the same.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def same_registers(self) -&gt; bool:
    &#34;&#34;&#34;Checks if the read and write registers are the same.&#34;&#34;&#34;
    same = set(self.write_names) == set(self.read_names)
    return same</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tdaq.Updater.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Read from Labjack registers.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>read_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict in the format <code>{register_name : data}</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self) -&gt; dict:
    &#34;&#34;&#34;Read from Labjack registers.

    Returns
    -------
    read_dict : dict
        Dict in the format ``{register_name : data}``.
    &#34;&#34;&#34;
    read_data = ljm.eReadNames(
        self._handle, len(self.read_names), self.read_names
        )
    read_dict = {
        name: data for name, data in zip(self.read_names, read_data)
        }
    return read_dict</code></pre>
</details>
</dd>
<dt id="tdaq.Updater.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, datas) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Write to and read from Labjack.</p>
<p>If read and write registers are different then reads from
object-defined read registers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datas</code></strong> :&ensp;<code>tuple, list</code> or <code>anything</code></dt>
<dd>Input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>read_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code><a title="tdaq.Updater.read" href="#tdaq.Updater.read">Updater.read()</a></code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Length of data to write doesn't match number of write registers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, datas) -&gt; dict:
    &#34;&#34;&#34;Write to and read from Labjack.

    If read and write registers are different then reads from
    object-defined read registers.

    Parameters
    ----------
    datas : tuple, list or anything
        Input data.

    Returns
    -------
    read_dict : dict
        See ``Updater.read``.

    Raises
    ------
    ValueError
        Length of data to write doesn&#39;t match number of write registers.
    &#34;&#34;&#34;
    # ljm.eReadNames only works with list/tuple names so must be converted
    iter_datas = convert_input(datas)

    if len(iter_datas) != len(self.write_names):
        raise ValueError(
            &#34;Length of data to write doesn&#39;t match number of write registers&#34;
            )

    ljm.eWriteNames(
        self._handle, len(self.write_names), self.write_names, iter_datas
        )

    if self.same_registers:
        # Read the same registers after writing to them.
        read_data = ljm.eReadNames(
            self._handle, len(self.write_names), self.write_names
            )
        read_dict = {
            name: data for name, data in zip(self.write_names, read_data)
            }
    else:
        read_dict = self.read()

    return read_dict</code></pre>
</details>
</dd>
<dt id="tdaq.Updater.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, datas)</span>
</code></dt>
<dd>
<div class="desc"><p>Write to Labjack registers with input data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datas</code></strong> :&ensp;<code>tuple, list</code> or <code>anything</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, datas):
    &#34;&#34;&#34;Write to Labjack registers with input data.

    Parameters
    ----------
    datas : tuple, list or anything
    &#34;&#34;&#34;
    # Single-valued data is converted into a list
    iter_datas = convert_input(datas)

    if len(iter_datas) != len(self.write_names):
        raise ValueError

    ljm.eWriteNames(
        self._handle, len(self.write_names), self.write_names, iter_datas
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#labjack-daq">LabJack-DAQ</a><ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tdaq.convert_input" href="#tdaq.convert_input">convert_input</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tdaq.AsynchUpdater" href="#tdaq.AsynchUpdater">AsynchUpdater</a></code></h4>
<ul class="two-column">
<li><code><a title="tdaq.AsynchUpdater.experiment" href="#tdaq.AsynchUpdater.experiment">experiment</a></code></li>
<li><code><a title="tdaq.AsynchUpdater.init_asynch" href="#tdaq.AsynchUpdater.init_asynch">init_asynch</a></code></li>
<li><code><a title="tdaq.AsynchUpdater.min_time_interval" href="#tdaq.AsynchUpdater.min_time_interval">min_time_interval</a></code></li>
<li><code><a title="tdaq.AsynchUpdater.receive" href="#tdaq.AsynchUpdater.receive">receive</a></code></li>
<li><code><a title="tdaq.AsynchUpdater.transmit" href="#tdaq.AsynchUpdater.transmit">transmit</a></code></li>
<li><code><a title="tdaq.AsynchUpdater.with_configuration" href="#tdaq.AsynchUpdater.with_configuration">with_configuration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tdaq.Intervaler" href="#tdaq.Intervaler">Intervaler</a></code></h4>
<ul class="">
<li><code><a title="tdaq.Intervaler.start_interval" href="#tdaq.Intervaler.start_interval">start_interval</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tdaq.LabJackDaq" href="#tdaq.LabJackDaq">LabJackDaq</a></code></h4>
<ul class="two-column">
<li><code><a title="tdaq.LabJackDaq.add_asynch" href="#tdaq.LabJackDaq.add_asynch">add_asynch</a></code></li>
<li><code><a title="tdaq.LabJackDaq.add_interval" href="#tdaq.LabJackDaq.add_interval">add_interval</a></code></li>
<li><code><a title="tdaq.LabJackDaq.add_stream_out" href="#tdaq.LabJackDaq.add_stream_out">add_stream_out</a></code></li>
<li><code><a title="tdaq.LabJackDaq.add_update" href="#tdaq.LabJackDaq.add_update">add_update</a></code></li>
<li><code><a title="tdaq.LabJackDaq.close" href="#tdaq.LabJackDaq.close">close</a></code></li>
<li><code><a title="tdaq.LabJackDaq.experiment" href="#tdaq.LabJackDaq.experiment">experiment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tdaq.Streamer" href="#tdaq.Streamer">Streamer</a></code></h4>
<ul class="two-column">
<li><code><a title="tdaq.Streamer.configure_stream" href="#tdaq.Streamer.configure_stream">configure_stream</a></code></li>
<li><code><a title="tdaq.Streamer.init_reset" href="#tdaq.Streamer.init_reset">init_reset</a></code></li>
<li><code><a title="tdaq.Streamer.load_data" href="#tdaq.Streamer.load_data">load_data</a></code></li>
<li><code><a title="tdaq.Streamer.out_addresses" href="#tdaq.Streamer.out_addresses">out_addresses</a></code></li>
<li><code><a title="tdaq.Streamer.reset_stream" href="#tdaq.Streamer.reset_stream">reset_stream</a></code></li>
<li><code><a title="tdaq.Streamer.scan_list" href="#tdaq.Streamer.scan_list">scan_list</a></code></li>
<li><code><a title="tdaq.Streamer.start_stream" href="#tdaq.Streamer.start_stream">start_stream</a></code></li>
<li><code><a title="tdaq.Streamer.stop_stream" href="#tdaq.Streamer.stop_stream">stop_stream</a></code></li>
<li><code><a title="tdaq.Streamer.stream_nums" href="#tdaq.Streamer.stream_nums">stream_nums</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tdaq.Updater" href="#tdaq.Updater">Updater</a></code></h4>
<ul class="">
<li><code><a title="tdaq.Updater.read" href="#tdaq.Updater.read">read</a></code></li>
<li><code><a title="tdaq.Updater.same_registers" href="#tdaq.Updater.same_registers">same_registers</a></code></li>
<li><code><a title="tdaq.Updater.update" href="#tdaq.Updater.update">update</a></code></li>
<li><code><a title="tdaq.Updater.write" href="#tdaq.Updater.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>